package main

import (
	"encoding/json"
	"flag"
	"fmt"
	"io/ioutil"
	"log"
	"math/rand"
	"net/http"
	"os"
	"strconv"
	"strings"
	"text/template"
	"time"
)

var PORT string
var yang = "higgyhiggy"

///////////////////////////////
var textt []byte

type Mynotes struct {
	Passing string
	Fname   string
}

var Ohtml = Mynotes{"", ""}

func check(e error) {
	if e != nil {
		panic(e)
	}
}

var name bool
var Cmdout string

type AutoGenerated []struct {
	Text   string `json:"text"`
	Author string `json:"author"`
}

var Word = AutoGenerated{}
var Txtname string
var port int

// takes port number as imput we pick
func main() {
//GET USER INPUT FOR PORT NUMBER
	PORT = strconv.Itoa(port)

	fmt.Printf("Host started on port %s\n", PORT)
	//prints out when we hit that port along with the path of it /yoyo/lol
	// THIS HANDLE FUNC VALIDATES THE TOKEN TO SEE IF THE HAVE ACCESS 
	//IF THEY DONT THEY GET DENIED ACCESS

	http.HandleFunc("/", func(w http.ResponseWriter, req *http.Request) {

		answer := req.Header.Get("ying")
		// shoul i let throught or block
		if yang != answer {
			fmt.Println("Access Denied ", req.RemoteAddr)
			w.WriteHeader(http.StatusBadRequest)
			w.Write([]byte("Acess Denied"))
			return
		}
		//if we let them in
		//hee(w, req)
		//IF THEY HAVE ACCESS THEN THEY WILL GET THE REDERING OF THE PAGE 
		// HERE IS WHERE WE WHERE WE LOAD OUR VARIABLES INTO THE HTML PAGE THAT WILL RENDER
		//tempate created
		//parsed for variables then replaces with teh named files
		tmpl := template.Must(template.ParseFiles("web/higgy.html"))
		// here is where the writer actaully write  into the htmpl
		tmpl.Execute(w, Ohtml)
// writting to the page
		w.Write([]byte("Acess GRANTED!!!"))
		//logging of who is it that is accessing the page
		fmt.Println(getIP(req), "---> requested this host ")

		ua := req.Header.Get("User-Agent")
		//tu := req.Header.Get("host")

		println(ua)

	})
	//////////////////////////////////////
//	CREATION OF FILES THAT WILL BE DISPLAYED ON THE PAGE
	content, err := ioutil.ReadFile(Txtname)
	if err != nil {
		check(err)
	}
	// LOADING THE DATA THAT SO IT CAN BE LOADED INTO THE HTML FILE FOR LATER USE
	textt = content
	Ohtml.Passing = string(textt)
	Ohtml.Fname = string(Txtname)

	////////////////////////////////////
	//LISTENING AT SPECIFIED PORT
	tee := http.ListenAndServe(":"+PORT, nil)
	if tee != nil {
		log.Fatal("ListenAndServe: ", tee)
	}
}

// to get ip address
func getIP(r *http.Request) string {
	forwarded := r.Header.Get("X-FORWARDED-FOR")
	if forwarded != "" {
		return forwarded
	}
	return r.RemoteAddr
}

//////////////////////////////////////////////////////////////////////////////
/* func hee(w http.ResponseWriter, r *http.Request) {
	tmpl := template.Must(template.ParseFiles("web/higgy.html"))
	tmpl.Execute(w, Ohtml)
} */

func init() {
	//flags creates the flags
	//-file to specify the name of the file
	flag.BoolVar(&name, "file", false, "define the file name to open or create: ")
	flag.IntVar(&port, "p", 8000, "specify port to use.  defaults to 8000.")
	//flag.Parse()
	// parser reads the flags
	flag.Parse()

	// to seed the random
	rand.Seed(time.Now().UnixNano())
	// opening where we will be extracting the json of quotes
	resp, err := http.Get("https://type.fit/api/quotes")
	//handles the erro if there is one when opening the quiotes page
	if err != nil {
		panic(err)
	}

	//closes requested page so it does not take up our resourse
	defer resp.Body.Close()
	//makes json into our struct to access the fields we need
	err = json.NewDecoder(resp.Body).Decode(&Word)
	//stores the file name that we will be using
	Txtname = Create(name)
	// creates the file with the specified name
	f, err := os.Create(Txtname)
	if err != nil {

	}
	//closed the created file since we can use that method for i/o
	defer f.Close()
	//managing the quote by making it smaller when its a long phrase
	shorter := strings.Split(Word[rand.Intn(len(Word))].Text, ".")
	// iterating the throught the modified quotes to be inserted into our file
	for _, v := range shorter {
		// writting into our file but making ever letter upper case
		n2, _ := f.WriteString(strings.ToUpper(v) + "\n")
		//handling the variable declared but not used
		if n2 == 0 {

		}
	}

	Cmdout = "the file created is " + string(Txtname) + " by user " + os.Getenv("USER")
	fmt.Println(Cmdout)
	// here is where we handle the cat output to the user

}

//Create if a fucntion can create a file at a specified location
//it has some default fall backs if the file name is missing or if the path is missing as well
// and if the flag is missing also
func Create(name bool) string {
	var n string
	//here we see flag to set name is active to to choose a specifc name if not a random one is general one is given
	if name {
		fmt.Println(len(os.Args))
		//these condition statement are to handle the erros if they put the flag but dont put a name
		if len(os.Args) >= 4 {

			n = time.Now().Format("jan-02-2006") + " " + time.Now().Format("03:04:05 PM") + ": " + "quicknotes"
			//fmt.Println(n, 3)
			os.MkdirAll(os.Args[3], 0777)
		} else if len(os.Args) == 3 {

			n = time.Now().Format("jan-02-2006") + " " + time.Now().Format("03:04:05 PM") + ": " + "quicknotes"
			//fmt.Println(n, 2)
		} else {
			n = time.Now().Format("jan-02-2006") + " " + time.Now().Format("03:04:05 PM") + ": " + "quicknotes"
			//fmt.Println(n, 0)
		}

	} else {
		n = time.Now().Format("jan-02-2006") + " " + time.Now().Format("03:04:05 PM") + ": " + "quicknotes"
		//fmt.Println(n, 0)
	}
	//return n

	//fmt.Println(n)
	// n the name the file will have
	return n
}
